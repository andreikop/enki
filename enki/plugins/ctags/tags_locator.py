"""
tags_locator --- ShowTags command for Locator
======================================================
"""

import os.path
import glob
import re

from enki.core.core import core
from enki.core.workspace import Workspace
from tags_completer import TagsCompleter, HidedField
from enki.core.locator import AbstractCommand


class CommandShowTags(AbstractCommand):
    """Command implementation displaing tags for current document, previously
    generated by ctags. Algorithm of matching tags and typed word based on fuzzy searching.
    """
    @staticmethod
    def signature():
        return 't [word]'
    
    @staticmethod
    def description():
        return 'Show tags (symbols) for current document'

    @staticmethod
    def pattern():
        """Match only C/C++ indentifiers. For distinguish tags with same identifiers
        to typed word added separator ;" and offset of relativity to first
        similar tags
        """
        from pyparsing import Literal, Optional, Suppress, White, Word, srange  # delayed import, performance optimization

        tag = Word(srange("[a-zA-Z_]"), srange("[a-zA-Z0-9_]"))("tag")
        offsetOfIdenticalTags = Word(srange("[0-9]"))("offset")
        pat = (Literal('t ') + Suppress(Optional(White())) + Optional(tag)
               + Optional(Literal(HidedField.SEPARATOR)) + Optional(offsetOfIdenticalTags))
        pat.leaveWhitespace()
        pat.setParseAction(CommandShowTags.create)
        return pat
    
    @staticmethod
    def create(str, loc, tocs):
        """tocs contain typed tag for searching and offset between similar tags
        Return instance of CommandShowTags
        """
        return [CommandShowTags(tocs.tag, tocs.offset)]

    @staticmethod
    def isAvailable():
        """Tags available only for opened document
        and if file ".tags" exist in directory with this document
        """
        from errno import ENOENT
        
        haveDocument = core.workspace().currentDocument() is not None
        
        if haveDocument:
            openedDoc = core.workspace().currentDocument()
            tagsFileDir = os.path.dirname(openedDoc.filePath())
            tagsFile = os.path.join(tagsFileDir, ".tags")
            haveDocument = os.path.exists(tagsFile)
        return haveDocument

    """SymbolsDict is a dictionary, where:
    key is tag name;
    value - list of tags adresses, because tag may be declared in some places of one document.
    It is global, for preventing scanning tags file each time when created new instance of CommandShowTags
    and called only methods like isReadyToExecute
    """
    SymbolsDict = {}
    
    @staticmethod
    def loadTagFile(path, documentName, isGlobalScope):
        """Load and parse tags file as described in http://ctags.sourceforge.net/FORMAT
        Result of parsing stores in SymbolsDict
        """
        from errno import ENOENT
        
        try:
            tagsFile = open(path, 'r')
            lines = tagsFile.readlines()
            tagsFile.close()
        except OSError, ex:
            if ex.errno != ENOENT: 
                error = unicode(str(ex), 'utf8')
                text = "Failed opening file '%s': %s" % (path, error)
                core.mainWindow().appendMessage(text)
        
        absDirPath = os.path.dirname(path)
        rootProjectDir = os.path.basename(absDirPath)
        
        for line in lines:
            #   Skip tag file information
            if line.startswith("!_"):
                continue
            parts = line.split('\t', 2)
            #   Extract tags only for current document
            tagName = parts[0]
            tagFile = parts[1]
            rest = parts[2]
            if (not isGlobalScope) and (tagFile != documentName):
                continue
            #   Extract tag absolute address
            parts = rest.split(";\"\t")
            if len(parts) == 1:
                tagAddress = parts[0]
            elif len(parts) == 2:
                tagAddress = parts[0]
                tagExtensionFields = parts[1]
            else:
                print "CommandShowTags::completer incorrect tag format =", line
            #   Store tag name and it address in SymbolsDict
            symbol = CommandShowTags.SymbolsDict.get(tagName, [])
            if isGlobalScope:
                tagFile = os.path.join(rootProjectDir, tagFile)
                symbol.append((tagAddress, tagFile))
            else:
                symbol.append((tagAddress, tagFile))
            CommandShowTags.SymbolsDict[tagName] = symbol
        
    def __init__(self, tag, offset):
        """offset is number of relativity to first duplicated tags
        """
        self._fuzzy_word = unicode(tag)
        if offset is not "":
            self._offsetOfIdenticalTags = int(offset)
        else:
            self._offsetOfIdenticalTags = 0
    
    def completer(self, text, pos):
        """Load tags for current document and call TagsCompleter for fuzzy searching and displaying results
        """
        openedDoc = core.workspace().currentDocument()
        CommandShowTags.SymbolsDict = {}
        
        #   Load local scope tags
        (tagsFileDir, docName) = os.path.split(openedDoc.filePath())
        tagsFileName = os.path.join(tagsFileDir, ".tags")
        CommandShowTags.loadTagFile(tagsFileName, docName, False)
        #   Load global scope tags
        tagsFileName = self._globalTagFilePath()
        if tagsFileName != "":
            CommandShowTags.loadTagFile(tagsFileName, docName, True)
        return TagsCompleter(self._fuzzy_word.lower(), CommandShowTags.SymbolsDict)

    def constructCommand(self, completableText):
        """Construct command by typed tag
        """
        #print "CommandShowTags::constructCommand", completableText
        return 't ' + completableText
    
    def isReadyToExecute(self):
        """Return True if SymbolsDict have typed tag.
        Store real address of choosed tag (for distinguish between similar tags)
        """
        #print "CommandShowTags::isReadyToExecute", self._fuzzy_word, self._offsetOfIdenticalTags
        if self._fuzzy_word not in CommandShowTags.SymbolsDict:
            return False
        
        tagAddresses = CommandShowTags.SymbolsDict[self._fuzzy_word]
        if self._offsetOfIdenticalTags >= len(tagAddresses):
            print "CommandShowTags::isReadyToExecute Warn: Incorrect tag file", self._offsetOfIdenticalTags, tagAddresses
            return False
        
        (self._address, self._documentPath) = tagAddresses[self._offsetOfIdenticalTags]
        tagsFileName = self._globalTagFilePath()
        #if tagsFileName == "":
            #self._documentPath = core.workspace().currentDocument().filePath()
        #else:
            #projectDir = os.path.dirname(tagsFileName)
            #baseDir = os.path.dirname(projectDir)
            #self._documentPath  = os.path.join(baseDir, self._documentPath)
            
        return True

    def execute(self):
        """Rewind document to position of tag, which pointed by field tagAddress in ctags file.
        tagAddress may be:
        - A decimal line number;
        - A search command - defined as regular expression.
        - Combination of both addressing modes, like:
            /^int c;$/
            /struct xyz {/;/int count;/
            389;/struct foo/;/char *s;/
        """
        from errno import ENOENT

        address = self._address
        #print "CommandShowTags::execute", address
        
        #   Address is decimal line number. Rewind document
        if address.isdigit():
            self._selectTag(int(address) - 1)
            return
        
        try:
            document = open(self._documentPath, 'r')
            documentContent = document.read()
            document.close()
        except OSError, ex:
            if ex.errno != ENOENT: 
                error = unicode(str(ex), 'utf8')
                text = "Failed opening file '%s': %s" % (self._documentPath, error)
                core.mainWindow().appendMessage(text)
                return
        
        #   Parsing combination of line number and regular expression.
        
        #   Check for a decimal line number
        lineNumber = 0
        if address[0].isdigit():
            i = 0
            while address[i].isdigit:
                i += 1
            lineNumber = int(address[0 : i - 1])
            address = address[0 : i] # remove line number and semicolon
        address = address[1 : -1] # remove heading and trailing slashes
        
        absPos = 0  #   TODO add convert line number to absolute position in document
        #   Divide tagAddress(now it may contain only regular expressions) on parts
        # and find next part only after previous part was finded
        parts = address.split("/;/")
        if len(parts) == 0:
            print "CommandShowTags::execute Warn: Incorrect tagAddress =", self._address
            return
        for exp in parts:
            #   Making correct pythonic regular expression
            haveCaret = False
            haveEnd = False
            if exp.startswith("^"):
                haveCaret = True
                exp = exp[1 : ]
            if exp.endswith('$'):
                haveEnd = True
                exp = exp[ : -1]
            exp = re.escape(exp)
            if haveCaret:
                exp = '^' + exp
            if haveEnd:
                exp = exp + '$'
            regExp = re.compile(exp, re.M)
            #   Find tag in entire document
#            text = core.workspace().currentDocument().text()
            matchObject = regExp.search(documentContent, absPos)
            if matchObject is None:
                print "CommandShowTags::execute Info: Can't find", '\"' + self._fuzzy_word + '\"', "in document"
                return
            absPos = matchObject.start()
            
        #   Rewind document and select tag in line, started from linePos
        exp = '\\b' + self._fuzzy_word + '\\b'
        regExp = re.compile(exp)
        matchObject = regExp.search(documentContent, absPos)
        if matchObject is None:
            print "CommandShowTags::execute Info: Can't find", '\"' + self._fuzzy_word + '\"', "in document"
            return
        openedDocPath = core.workspace().currentDocument().filePath()
        if (self._documentPath == openedDocPath):
            core.workspace().currentDocument().goTo(absPos = matchObject.start(),
                                                    selectionLength = len(self._fuzzy_word))
        else:
            core.workspace().goTo(self._documentPath, absPos = matchObject.start(),
                                  selectionLength = len(self._fuzzy_word))

    def _globalTagFilePath(self):
        """Scanning file system tree from current directory to root, while
        doesn't find Global scope tags file.
        Return path to this file, if it exist. Otherwise - return empty string.
        """
        openedDoc = core.workspace().currentDocument()
        (tagsFileDir, prevDir) = os.path.split(openedDoc.filePath())
        while (os.path.exists(tagsFileDir) and (prevDir != "")):
            tagsFileName = os.path.join(tagsFileDir, ".tags_global_scope")
            if os.path.exists(tagsFileName):
                return tagsFileName
            (tagsFileDir, prevDir) = os.path.split(tagsFileDir) # choose upper directory
        return ""
